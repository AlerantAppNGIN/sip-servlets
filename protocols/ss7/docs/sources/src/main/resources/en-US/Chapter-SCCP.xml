<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [<!ENTITY % BOOK_ENTITIES SYSTEM "SS7_Stack_User_Guide.ent">%BOOK_ENTITIES;]>

<chapter
	id="sccp">

	<title>SCCP</title>
	<para>The Signaling Connection Control Part (SCCP) is defined in ITU-T Recommendations Q.711-Q.716.
	SCCP sits on top of Message Transfer Part 3 (MTP3) in the SS7 protocol stack. 
	The SCCP provides additional network layer functions to provide transfer of noncircuit-related (NCR) signaling information, 
	application management procedures and alternative and more flexible methods of routing. 
	</para>
	<section
		id="sccp_routing">
		<title>Routing Management</title>
		<para>
			Currently
			<literal>Shell</literal>
			does not support commands to manage
			<literal>SCCP</literal>
			routes.
		</para>


	</section>
	<section
		id="sccp_routing_configuration">
		<title>Routing Configuration</title>
		<para>
			Routing rules are persisted within file. By default its
			<filename>sccp-routing.txt</filename>. 
			This file is managed by
			<literal>SCCP</literal>
			stack and
			<literal>SS7 Service</literal>
			, it is not encouraged practice to edit this file by hand. However for complete rerefence, you can find structure of this file below:
		</para>

		<programlisting
			language="XML"
			role="XML"><![CDATA[
sequence;pattern;translation;mtpinfo
]]>
				</programlisting>
		<note>
			<para>
				Fields within
				<literal>pattern</literal>
				,
				<literal>translation</literal>
				and
				<literal>mtp</literal>
				,
				separated by
				<literal>#</literal>
				, empty value is indicated by single
				<literal>space</literal>
				. Each part of routing entry is separated by
				<literal>;</literal>
				.
			</para>
		</note>
		<variablelist>
			<varlistentry>
				<term>sequence</term>
				<listitem>
					<para>is simple sequence number, each entry increases it by 1.</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>pattern</term>
				<listitem>
					<para>
						is simply
						<literal>SCCP</literal>
						like regular expresion. Destination address of message is matched against this to check which rule should be triggered.
					</para>

					<table
						frame="all"
						pgwide="1">
						<title>pattern content</title>
						<tgroup
							colsep="1"
							cols="3">
							<colspec
								colnum="1"
								colname="c0" />
							<colspec
								colnum="2"
								colname="c1" />
							<colspec
								colnum="3"
								colname="c2" />
							<thead>
								<row>
									<entry>Name</entry>
									<entry>Type</entry>
									<entry>Description</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>translation type</entry>
									<entry>java.lang.Integer</entry>
									<entry>Network specific ID which determines how global title analysis is performed.</entry>
								</row>
								<row>
									<entry>numbering plan</entry>
									<entry>enum</entry>
									<entry>Determines which numbering plan is used for global title. It can have one of following values:
										UNKNOWN, ISDN_TELEPHONY, DATA,
										TELEX, MERITIME_MOBILE, LAND_MOBILE, ISDN_MOBILE</entry>
								</row>
								<row>
									<entry>nature of address</entry>
									<entry>enum</entry>
									<entry>Determines type of address. It can have one of following values:
										SPARE, SUBSCRIBER, UNKNOWN, NATIONAL, INTERNATIONAL</entry>
								</row>
								<row>
									<entry>digits</entry>
									<entry>java.lang.String</entry>
									<entry>Simply digits of number, ie: +91 417688345892</entry>
								</row>
								<row>
									<entry>sub-system number</entry>
									<entry>java.lang.Integer</entry>
									<entry>local subsystem number, used to route between local services in SS7, ie. between HLR and VLR.</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>translation</term>
				<listitem>
					<para>
						has the same structure as
						<literal>pattern</literal>
						. If
						<literal>pattern</literal>
						matches, destintion address is changed to
						<literal>translation</literal>
						.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>mtpinfo</term>
				<listitem>
					<para>
						<literal>mtpinfo</literal>
						indicates which link should be chosen when routing to remote location. In case routing is performed localy, its not present.
					</para>
					<table
						frame="all"
						pgwide="1">
						<title>mtpinfo content</title>
						<tgroup
							colsep="1"
							cols="3">
							<colspec
								colnum="1"
								colname="c0" />
							<colspec
								colnum="2"
								colname="c1" />
							<colspec
								colnum="3"
								colname="c2" />
							<thead>
								<row>
									<entry>Name</entry>
									<entry>Type</entry>
									<entry>Description</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>name</entry>
									<entry>java.lang.String</entry>
									<entry></entry>
								</row>
								<row>
									<entry>adjacent point code</entry>
									<entry>java.lang.Integer</entry>
									<entry>point code of remote, mtp link.</entry>
								</row>
								<row>
									<entry>origin point code</entry>
									<entry>java.lang.Integer</entry>
									<entry>polint code of local, mtp link.</entry>
								</row>
								<row>
									<entry>signaling link selector</entry>
									<entry>java.lang.Integer</entry>
									<entry>number indicating TDM multiplexed link.</entry>
								</row>


							</tbody>
						</tgroup>
					</table>
				</listitem>
			</varlistentry>
		</variablelist>
		<para>Example file entry looks as follows:</para>
		<!-- bad xml? -->
		<example>
			<title>sccp-routing.txt example entry</title>
			<programlisting
				language="XML"
				role="XML"><![CDATA[
0; #ISDN_MOBILE#NATIONAL#9023629581# ; #ISDN_MOBILE#INTERNATIONAL#79023629581# ;linkset#14083#14155#0
]]>
				</programlisting>
		</example>
		
		<variablelist>
			<varlistentry>
				<term>sequence</term>
				<listitem>
					<para> is set to 0, since its only rule in a file(or first).</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>pattern</term>
				<listitem>
					<para>matches natioan mobile number with following digits: <literal>9023629581</literal> </para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>translation</term>
				<listitem>
					<para>changes destination to international mobile with following digits: <literal>79023629581</literal>. Since no sub-system number is present, this rule requires <literal>mtpinfo</literal> 
					to indicate target.</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>mtpinfo</term>
				<listitem>
					<para>indicates link through which message will be sent to next hop. Link:</para>
					<itemizedlist>
						<listitem>
							<para>Belongs to linkset with name equal to <literal>linkset</literal>. </para>
						</listitem>
						<listitem>
							<para>Adjacent point code is equal to <literal>14083</literal>. </para>
						</listitem>
						<listitem>
							<para>Origin point code is equal to <literal>14155</literal>. </para>
						</listitem>
						<listitem>
							<para>Signaling link selector is equal to <literal>0</literal>. Note that this value may be overriden by transport layer.  </para>
						</listitem>
						
					</itemizedlist>
				</listitem>
			</varlistentry>
		</variablelist>
	</section>
	<section id="sccp_design">
		<title>&THIS.PLATFORM; &THIS.APPLICATION; SCCP Usage</title>
		<para>
			The <classname>org.mobicents.protocols.ss7.sccp.SccpStack</classname> is responsible for taking the 
			config file and turning it into <classname>org.mobicents.protocols.ss7.sccp.Router</classname>. 
			All the sccp messages sent bu SCCP User Part are routed as per the rule configured in Router
		</para>
		<para>
			The SCCP User Part gets handle to <classname>SccpStack</classname> by doing JNDI look-up as
			explained in <xref linkend="sccp_access_point"/> 
		</para>
		
		<para>
			<classname>SccpStack</classname> exposes <classname>org.mobicents.protocols.ss7.sccp.SccpProvider</classname> 
			that interacts directly with SccpStack. This interface defines the methods that will be used by SCCP User Part to send 
			<classname>org.mobicents.protocols.ss7.sccp.message.SccpMessage</classname> and register 
			<classname>org.mobicents.protocols.ss7.sccp.SccpListener</classname>'s to listen for incoming SCCP messages. 
		</para>
		
		<para>
			SCCP User Part registers SccpListener for specific local <classname>org.mobicents.protocols.ss7.sccp.parameter.SccpAddress</classname>.
			For every incoming SccpMessage, if the called party address matches with this local SccpAddress, the corresponding SccpListner is called.
		</para>
		
		<para>
			SccpProvider also exposes <classname>org.mobicents.protocols.ss7.sccp.message.MessageFactory</classname> and
			<classname>org.mobicents.protocols.ss7.sccp.parameter.ParameterFactory</classname> to create new concrete SccpMessage viz.,
			<classname>org.mobicents.protocols.ss7.sccp.message.UnitData</classname> or 
			<classname>org.mobicents.protocols.ss7.sccp.message.XUnitData</classname> passing the corresponding parameters created by leveraging 
			ParameterFactory.
		</para>
		
		<para>
			The UML class diagram looks like
		</para>
		
		<mediaobject
			id="sccp_classdia">
			<imageobject>
				<imagedata
					width="300px"
					align="center"
					fileref="images/SCCPClassDiagram.png"
					format="PNG" />
			</imageobject>
			<caption>
				<para>&THIS.PLATFORM; &THIS.APPLICATION; SCCP Class Diagram
				</para>
			</caption>
		</mediaobject>			
	</section>
	<section
		id="sccp_access_point">
		<title>Access Point</title>
		<para>
			<literal>SS7 Service</literal> provides user with access point to <literal>SCCP</literal> protocol/stack.		
		</para>
		<para>
			To get handle to <classname>SccpStack</classname> do the JNDI look-up passing the 
			JNDI name configured in SS7 service as explained in <xref linkend="configuring_SS7Service"/> 
		</para>			
		<programlisting
			language="Java"
			role="JAVA"><![CDATA[	
	    private static SccpProvider getSccpProvider() throws NamingException {
	
	        // no arg is ok, if we run in JBoss
	        InitialContext ctx = new InitialContext();
	        try {
	            String providerJndiName = "/mobicents/ss7/sccp";
	            return ((SccpStack) ctx.lookup(providerJndiName)).getSccpProvider();
	
	        } finally {
	            ctx.close();
	        }
	    }
			]]>
		</programlisting>		
	</section>	
	<section
		id="sccp_complete_example">
		<title>SCCP User Part Example</title>
		<para>
			Below is SCCP User Part example listening for incoming SCCP message and sending back new message		
		</para>		
		<programlisting language="java" role="JAVA">
public class Test implements SccpListener {

    private SccpProvider sccpProvider;
    private SccpAddress localAddress;

    private static SccpProvider getSccpProvider() throws NamingException {

        // no arg is ok, if we run in JBoss
        InitialContext ctx = new InitialContext();
        try {
            String providerJndiName = "/mobicents/ss7/sccp";
            return ((SccpStack) ctx.lookup(providerJndiName)).getSccpProvider();
        } finally {
            ctx.close();
        }
    }

    public void start() throws Excetpion {

        this.sccpProvider = getSccpProvider();

        int translationType = 0;
        int subSystemNumber = 0;

        GlobalTitle gt = GlobalTitle.getInstance(translationType,
                NumberingPlan.ISDN_MOBILE, NatureOfAddress.NATIONAL, "1234");

        localAddress = new SccpAddress(gt, 0);

        this.sccpProvider.registerSccpListener(localAddress, this);
    }

    public void stop() {
        this.sccpProvider.deregisterSccpListener(localAddress);
    }

    public void onMessage(SccpMessage message) {

        if (message.getType() == MessageType.UDT) {
            throw new IlleagalArgumentException("Dont like UDT");
        } else if (message.getType() == MessageType.XUDT) {
            XUnitData xudt = (XUnitData) message;
            localAddress = ((XUnitData) message).getCalledPartyAddress();
            SccpAddress remoteAddress = ((XUnitData) message)
                    .getCallingPartyAddress();

            // now decode content

            byte[] data = xudt.getData();

            // some data encoded in
            CallRequest cr = new CallRequest(data);

            byte[] answerData;

            if (cr.getCallee().equals(this.localAddress)) {
                EstablihsCallAnswer eca = new EstablihsCallAnswer(cr);
                answerData = eca.encode();

            } else {
                TearDownCallAnswer tdca = new TearDownCallAnswer(cr);
                answerData = tdca.encode();
            }

            HopCounter hc = this.sccpProvider.getParameterFactory()
                    .createHopCounter(5);

            XUnitData sccpAnswer = this.sccpProvider
                    .getMessageFactory()
                    .createXUnitData(hc, xudt.getProtocolClass(),
                            message.getCallingPartyAddress(), this.localAddress);

            this.sccpProvider.send(sccpAnswer);

        }

    }

}
		</programlisting>
	</section>
</chapter>